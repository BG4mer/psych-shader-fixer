<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GODLIKE Shader Fixer — Ultra Animated Single File</title>
<meta name="color-scheme" content="dark">
<style>
  /* ========== Fonts & base ========== */
  @font-face {
    font-family: "Xenomono";
    src: local("Courier New"), local("monospace");
  }
  :root{
    --bg1:#071025; --bg2:#0f1930; --accent1:#4ee0ff; --accent2:#b36bff;
    --glass: rgba(255,255,255,0.04);
    --success:#6ef0a2; --danger:#ff6b6b;
  }
  html,body{height:100%;margin:0;padding:0;background:linear-gradient(135deg,var(--bg1),var(--bg2));font-family:Xenomono,monospace;color:#e9eefc;overflow:hidden;}
  /* ========== animated background blobs ========== */
  .bg {
    position:fixed; inset:0; z-index:0; pointer-events:none; overflow:hidden;
    background:
      radial-gradient(800px 400px at 10% 20%, rgba(123,64,255,0.12), transparent 10%),
      radial-gradient(600px 300px at 80% 80%, rgba(78,224,255,0.08), transparent 10%);
    mix-blend-mode:screen;
    transition:opacity .6s ease;
  }
  .blob {
    position:absolute;border-radius:50%; filter:blur(60px); opacity:.55; transform:translate3d(0,0,0);
    animation: floaty linear infinite;
    will-change: transform;
  }
  .blob.a{width:520px;height:520px; left:-10%; top:5%; background:linear-gradient(45deg,#6b3dff,#00f0ff); animation-duration:24s;}
  .blob.b{width:360px;height:360px; right:-10%; bottom:0; background:linear-gradient(45deg,#ff66b3,#6b3dff); animation-duration:28s; opacity:.35;}
  @keyframes floaty{0%{transform:translateY(0) rotate(0deg) scale(1)}50%{transform:translateY(-40px) rotate(180deg) scale(1.05)}100%{transform:translateY(0) rotate(360deg) scale(1)}}

  /* ========== layout container ========== */
  .wrap { position:relative; z-index:2; width:100%; max-width:1100px; margin:20px auto; padding:18px; box-sizing:border-box; }
  .panel {
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:14px; padding:14px; box-shadow: 0 10px 30px rgba(0,0,0,0.6);
    border: 1px solid rgba(255,255,255,0.04); backdrop-filter: blur(6px);
  }
  header { display:flex; gap:12px; align-items:center; margin-bottom:12px; }
  .title {
    display:flex; flex-direction:column; gap:4px; flex:1;
  }
  h1 { margin:0; font-size:20px; color:var(--accent1); letter-spacing:0.6px; text-shadow:0 4px 20px rgba(78,224,255,0.08); }
  p.lead { margin:0; color:#bcd3ff66; font-size:12px; }

  /* ========== controls row ========== */
  .controls { display:flex; gap:10px; margin:10px 0; flex-wrap:wrap; }
  .btn {
    border:0; padding:12px 14px; border-radius:12px; cursor:pointer; font-weight:700; letter-spacing:0.6px;
    background:linear-gradient(90deg,var(--accent1),var(--accent2)); color:#041826; box-shadow: 0 6px 20px rgba(179,107,255,0.12); transition:transform .18s ease, box-shadow .18s ease;
  }
  .btn:active{ transform:translateY(1px) scale(.998); }
  .btn.ghost { background:transparent; color:#cfe9ff; border:1px solid rgba(255,255,255,0.04); box-shadow:none; }
  .fileWrap { position:relative; overflow:hidden; display:inline-block; }
  input[type=file]{ position:absolute; inset:0; opacity:0; cursor:pointer; }

  /* ========== two-column layout ========== */
  .grid { display:grid; grid-template-columns: 1fr 420px; gap:12px; margin-top:10px; align-items:start; }
  @media (max-width:980px){ .grid{grid-template-columns:1fr} .rightCol{order:2} }

  /* ========== editor area (faux code editor) ========== */
  .editorBox { min-height:400px; border-radius:12px; overflow:hidden; position:relative; }
  .ln { position:absolute; left:0; top:0; bottom:0; width:54px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0)); color:#9fb9ff66; padding:10px; box-sizing:border-box; font-size:12px; line-height:18px; user-select:none; }
  .codeArea {
    margin-left:54px; height:100%; width:100%; box-sizing:border-box; background:#081029; color:#dff3ff; font-family:monospace; font-size:13px; padding:10px; outline:none;
    caret-color:var(--accent1); resize:none; border:none; overflow:auto; line-height:18px; white-space:pre;
  }
  .codeArea[contenteditable]{ -webkit-user-select:text; }

  /* simple syntax highlighting */
  .tok-key{ color:#7ec7ff; } .tok-fn{ color:#ffd88e; } .tok-num{ color:#a5ffc9; } .tok-comment{ color:#8f99a6; font-style:italic; }
  .toolbar { display:flex; gap:8px; align-items:center; margin-bottom:8px; }

  /* ========== preview area ========== */
  .rightCol { display:flex; flex-direction:column; gap:8px; }
  .previewCard { padding:10px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); min-height:260px; position:relative; overflow:hidden; }
  #glcanvas { width:100%; height:260px; display:block; border-radius:8px; background:#000; }

  /* ========== output logs ========== */
  .log { height:140px; overflow:auto; background:rgba(0,0,0,0.25); padding:10px; border-radius:8px; font-size:12px; color:#cfe9ff; white-space:pre-wrap; }

  /* ========== progress & confetti ========== */
  .progressWrap{ height:8px; background:rgba(255,255,255,0.03); border-radius:8px; overflow:hidden; }
  .progress { height:100%; width:0%; background: linear-gradient(90deg,var(--accent1),var(--accent2)); transition:width .4s cubic-bezier(.2,.9,.2,1); box-shadow:0 6px 20px rgba(78,224,255,0.08); }
  /* confetti pieces */
  .confetti { position:fixed; z-index:9999; pointer-events:none; }

  /* ========== micro-animations for UI delight ========== */
  .pulse { animation: pulse 1.6s infinite; }
  @keyframes pulse { 0%{ transform:scale(1) }50%{ transform:scale(1.02) }100%{ transform:scale(1) } }
  .glitch {
    display:inline-block;
    position:relative;
  }
  .glitch::before, .glitch::after{
    content:attr(data-text);
    position:absolute; left:0; top:0; opacity:.6;
    clip-path:polygon(0 0,100% 0,100% 45%,0 45%);
  }
  .glitch::before{ transform:translate(-2px, -1px); color:#ff99cc; mix-blend-mode:screen; }
  .glitch::after{ transform:translate(2px, 1px); color:#66f0ff; mix-blend-mode:screen; opacity:.5; clip-path:polygon(0 55%,100% 55%,100% 100%,0 100%); }

  /* small helper styles */
  .muted{ color:#9fb9ff66; font-size:12px; }
  .small{ font-size:12px; }
  footer{ position:fixed; left:18px; bottom:18px; z-index:5; font-size:12px; color:#9fb9ff66; }
</style>
</head>
<body>

<div class="bg" aria-hidden="true">
  <div class="blob a"></div><div class="blob b"></div>
</div>

<div class="wrap">
  <div class="panel">
    <header>
      <div style="width:72px;height:72px;border-radius:12px;background:linear-gradient(135deg,var(--accent2),var(--accent1));display:flex;align-items:center;justify-content:center;box-shadow:0 10px 30px rgba(0,0,0,0.4);">
        <svg width="42" height="42" viewBox="0 0 24 24" fill="none" aria-hidden><path d="M2 12l3-3 4 4 8-8 5 5" stroke="#041826" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </div>
      <div class="title">
        <h1>GODLIKE Shader Fixer <span class="muted small">— Ultra Animated</span></h1>
        <p class="lead">Fix GLSL & Psych (.hx) fragment shaders, preview live, download patched shader.</p>
      </div>
      <div style="width:120px;text-align:right;">
        <div class="muted small">Status</div>
        <div id="statusDot" style="margin-top:6px;font-weight:800;color:var(--accent1);">Ready</div>
      </div>
    </header>

    <div class="controls">
      <div class="fileWrap">
        <button class="btn">Upload Shader</button>
        <input id="fileIn" type="file" accept=".frag,.hx,.glsl,.txt">
      </div>
      <button id="fixBtn" class="btn">AUTO-FIX (GODMODE)</button>
      <button id="previewBtn" class="btn ghost">Live Preview</button>
      <button id="downloadBtn" class="btn" style="display:none">Download Fixed</button>
      <div style="flex:1"></div>
      <button id="randomBtn" class="btn ghost">Inject Example</button>
    </div>

    <div class="grid">
      <!-- LEFT: Editor -->
      <div>
        <div class="editorBox panel" style="padding:12px;">
          <div class="toolbar" style="justify-content:space-between">
            <div>
              <span class="muted small">Shader Editor</span>
              <span id="langBadge" class="muted small" style="margin-left:10px">GLSL / Haxe</span>
            </div>
            <div style="display:flex;gap:8px;align-items:center">
              <div class="muted small">Lines: <span id="lineCount">0</span></div>
              <div style="width:10px"></div>
              <div class="muted small">Chars: <span id="charCount">0</span></div>
            </div>
          </div>

          <div style="position:relative;">
            <div class="ln" id="lineNumbers"></div>
            <div id="code" class="codeArea" contenteditable="true" spellcheck="false" aria-label="Shader code editor" ></div>
          </div>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
          <div class="progressWrap" style="flex:1"><div class="progress" id="progress"></div></div>
          <div style="width:120px;text-align:right"><span id="miniNote" class="muted small">No actions yet</span></div>
        </div>
      </div>

      <!-- RIGHT: Preview & logs -->
      <div class="rightCol">
        <div class="previewCard panel">
          <canvas id="glcanvas"></canvas>
        </div>

        <div class="panel">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
            <div class="muted small">Realtime Output / Fix Log</div>
            <div style="display:flex;gap:8px">
              <button id="copyLog" class="btn ghost small">Copy</button>
              <button id="clearLog" class="btn ghost small">Clear</button>
            </div>
          </div>
          <div class="log" id="log"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<canvas id="confettiCanvas" class="confetti"></canvas>
<footer>Open the file, paste or type shader, press AUTO-FIX, then Live Preview.</footer>

<script>
/* ===========================
   Utility & UI Helpers
   =========================== */
const codeEl = document.getElementById('code');
const lineNumbers = document.getElementById('lineNumbers');
const lineCountEl = document.getElementById('lineCount');
const charCountEl = document.getElementById('charCount');
const logEl = document.getElementById('log');
const progressEl = document.getElementById('progress');
const statusDot = document.getElementById('statusDot');
const fileIn = document.getElementById('fileIn');
const downloadBtn = document.getElementById('downloadBtn');
const glcanvas = document.getElementById('glcanvas');
const confettiCanvas = document.getElementById('confettiCanvas');

let fixedShaderText = '';
let currentFilename = 'fixed_shader.frag';

/* ---------- tiny safe logger ---------- */
function log(msg, level='info'){
  const time = new Date().toLocaleTimeString();
  const prefix = level==='err' ? '[ERROR]' : level==='warn' ? '[WARN]' : '[OK]';
  logEl.textContent = time + ' ' + prefix + ' ' + msg + '\n' + logEl.textContent;
}

/* ---------- update counters & lines ---------- */
function updateLineNumbers(){
  const text = codeEl.innerText.replace(/\t/g,'    ');
  const lines = text.split('\n');
  let html = '';
  for(let i=1;i<=lines.length;i++) html += i + '\n';
  lineNumbers.textContent = html;
  lineCountEl.textContent = lines.length;
  charCountEl.textContent = text.length;
}
codeEl.addEventListener('input',()=>{
  updateLineNumbers();
  // gentle syntax highlight: wrap tokens (non-destructive, uses innerHTML)
  // We'll do minimal highlighting so caret isn't messed up too much
  const txt = codeEl.innerText;
  let html = txt
    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    // comments
    .replace(/(\/\/.*?$)/gm, '<span class="tok-comment">$1</span>')
    // numbers
    .replace(/(\b\d+(\.\d+)?\b)/g, '<span class="tok-num">$1</span>')
    // keywords (basic)
    .replace(/\b(void|float|vec2|vec3|vec4|uniform|precision|if|else|for|while|return|main|varying|attribute|in|out|sampler2D)\b/g, '<span class="tok-key">$1</span>')
    // function-ish
    .replace(/(\b[a-zA-Z_]\w*(?=\())/g, '<span class="tok-fn">$1</span>');
  // preserve caret — using simple approach
  codeEl.innerHTML = html;
  placeCaretAtEnd(codeEl);
});

/* ---------- caret helper (keep cursor at end on highlight) ---------- */
function placeCaretAtEnd(el) {
  el.focus();
  if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
    const range = document.createRange();
    range.selectNodeContents(el);
    range.collapse(false);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }
}

/* initialize */
codeEl.innerText = `// Paste or write your fragment shader here
// Example: simple shader
precision mediump float;
uniform float uTime;
uniform vec2 uResolution;

void main(){
  vec2 uv = gl_FragCoord.xy / uResolution.xy;
  vec3 col = 0.5 + 0.5*cos(uTime + uv.xyx + vec3(0,2,4));
  gl_FragColor = vec4(col,1.0);
}`;
updateLineNumbers();

/* ========== File handling ========== */
document.querySelector('.fileWrap input[type=file]').addEventListener('change', async (ev)=>{
  const f = ev.target.files[0];
  if(!f) return;
  currentFilename = f.name;
  const text = await f.text();
  codeEl.innerText = text;
  updateLineNumbers();
  log('Loaded file: ' + f.name);
  setProgress(10);
});

/* ========= Fixer Engine (advanced heuristics) ========= */
function setProgress(p){
  progressEl.style.width = p + '%';
}
function setStatus(s){ statusDot.textContent = s; }

/* main fix function
   - add precision if missing
   - ensure main() exists
   - add Psych uniforms if missing (uTime,uResolution,uSampler)
   - replace deprecated functions (texture2D -> texture)
   - guard divisions by zero
   - fix common missing semicolons (smart)
   - auto-close braces and parentheses
*/
function godlikeFix(code){
  setStatus('Fixing...');
  setProgress(20);
  log('Starting GODMODE fix pass');

  let original = code;
  let out = code;

  // normalize line endings
  out = out.replace(/\r\n/g,'\n').replace(/\r/g,'\n');

  // 1) Ensure precision directive for fragment shader
  if(!/precision\s+(lowp|mediump|highp)\s+float\s*;/.test(out)){
    out = 'precision mediump float;\n' + out;
    log('Inserted missing precision mediump float;');
  }

  setProgress(30);

  // 2) Psych Engine uniforms defaults (only add if not present)
  const psychUniforms = [
    {search:/\buniform\s+float\s+uTime\b/,'decl':'uniform float uTime;'},
    {search:/\buniform\s+vec2\s+uResolution\b/,'decl':'uniform vec2 uResolution;'},
    {search:/\buniform\s+sampler2D\s+uSampler\b/,'decl':'uniform sampler2D uSampler;'}
  ];
  let adds=0;
  psychUniforms.forEach(u=>{
    if(!u.search.test(out)){
      out = u.decl + '\n' + out;
      adds++;
    }
  });
  if(adds) log('Added ' + adds + ' Psych Engine uniform declarations');

  setProgress(40);

  // 3) Replace deprecated texture2D with texture (WebGL2 style) but keep compatibility
  if(/texture2D\(/.test(out)){
    out = out.replace(/texture2D\(/g,'texture(');
    log('Translated texture2D() -> texture() for compatibility');
  }

  setProgress(50);

  // 4) Smart semicolon insertion:
  //   We only add semicolons to lines that look like statements but not to preprocessor, block starts, function headers
  out = out.split('\n').map((ln, idx)=>{
    const t = ln.trim();
    if(!t) return ln;
    if(t.startsWith('//')||t.startsWith('/*')||t.startsWith('*')||t.startsWith('#')) return ln;
    // function header detection: "void main() {" or "vec3 foo(vec2 a) {"
    if(/\b(if|for|while|else|return|struct)\b/.test(t)) return ln;
    if(/\)\s*{/.test(t) || /\{$/.test(t) || /\}$/.test(t)) return ln;
    // if line ends with ) or ; or , or : -> don't add
    if(/[;,\)\{\}]$/.test(t)) return ln;
    // if starts with 'uniform' or 'attribute' or 'varying' — add semicolon if missing
    if(/^(uniform|attribute|varying|in|out|const)\b/.test(t) && !t.endsWith(';')){
      return ln + ';';
    }
    // simple assignment detection: contains '=' and not function start
    if(/=/.test(t) && !/\b(if|for|while)\b/.test(t) && !/==/.test(t)){
      // avoid adding semicolon if it's function header accidentally caught
      return ln + ';';
    }
    return ln;
  }).join('\n');
  log('Performed smart semicolon insertion pass');

  setProgress(62);

  // 5) Guard divisions by zero: replace patterns like (x / y) with (x / max(y, 0.000001))
  //    only for obvious cases: / followed by variable or expression
  out = out.replace(/\/\s*\(?([a-zA-Z_]\w*(?:\.[xyzw]{1,4})?(?:\s*\)|\b)?)/g, (m, g1)=>{
    // avoid touching literal numbers
    if(/^\d/.test(g1)) return '/' + g1;
    // make simple guard
    return '/ max(' + g1 + ', 0.000001)';
  });
  log('Added division-by-zero guards where detected');

  setProgress(74);

  // 6) Close unbalanced braces & parentheses
  const opens = (out.match(/\{/g)||[]).length;
  const closes = (out.match(/\}/g)||[]).length;
  if(opens > closes){
    out += '\n' + '}'.repeat(opens - closes);
    log('Auto-closed ' + (opens-closes) + ' missing brace(s)');
  }
  const opar = (out.match(/\(/g)||[]).length;
  const cpar = (out.match(/\)/g)||[]).length;
  if(opar > cpar){
    out += ')'.repeat(opar-cpar);
    log('Auto-closed ' + (opar-cpar) + ' missing parenthesis');
  }

  setProgress(82);

  // 7) Replace 'gl_FragColor' with proper output if user uses newer style (we keep gl_FragColor but ensure declared)
  if(!/gl_FragColor/.test(out) && /\bmain\s*\(\s*\)/.test(out) && /vec4\s+/.test(out)){
    // no action — can't reliably invent variable — just warn
    log('Note: gl_FragColor not found; if using newer Shading Language outputs, ensure proper out variable is declared.');
  }

  // 8) Replace undefined tokens like "undefined" with safe defaults
  out = out.replace(/\bundefined\b/g,'0.0');
  log('Patched literal "undefined" -> 0.0');

  setProgress(90);

  // 9) Make sure main() exists; if not, wrap fragment body into minimal fragment main that writes black (best-effort)
  if(!/\bvoid\s+main\s*\(/.test(out)){
    out += '\nvoid main(){ gl_FragColor = vec4(0.0,0.0,0.0,1.0); }';
    log('No main() found — appended a safe main() to avoid compile error');
  }

  setProgress(96);

  // final normalization: trim trailing spaces
  out = out.replace(/[ \t]+$/gm, '');
  setProgress(100);
  setTimeout(()=>setProgress(0), 700);

  log('GODMODE fix pass complete');

  fixedShaderText = out;
  return out;
}

/* ========== Live WebGL Preview (very defensive) ========== */
const gl = glcanvas.getContext('webgl') || glcanvas.getContext('experimental-webgl');
if(!gl){
  log('WebGL not available in this browser — preview disabled', 'err');
  document.getElementById('previewBtn').disabled = true;
}

function resizeCanvasToDisplaySize(canvas){
  const displayWidth  = Math.floor(canvas.clientWidth * devicePixelRatio);
  const displayHeight = Math.floor(canvas.clientHeight * devicePixelRatio);
  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
    return true;
  }
  return false;
}

let animationRequest = null;
let compiledProgram = null;
let startTime = performance.now();

function compileAndRun(fragmentSource){
  if(!gl) return log('No WebGL context', 'err');
  resizeCanvasToDisplaySize(glcanvas);

  // minimal vertex shader
  const vsSrc = `
    attribute vec2 aPos;
    void main(){ gl_Position = vec4(aPos, 0.0, 1.0); }`;

  // attempt to compile shaders
  function createShader(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      const info = gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      throw new Error(info);
    }
    return s;
  }

  try{
    // wrap fragment if missing main guard etc (we rely on the fixer)
    const fs = createShader(gl.FRAGMENT_SHADER, fragmentSource);
    const vs = createShader(gl.VERTEX_SHADER, vsSrc);
    if(compiledProgram) {
      gl.deleteProgram(compiledProgram);
      compiledProgram = null;
    }
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
      const info = gl.getProgramInfoLog(prog);
      gl.deleteProgram(prog);
      throw new Error('Link error: ' + info);
    }
    compiledProgram = prog;
    // clean up shaders (attached)
    gl.detachShader(prog, vs); gl.detachShader(prog, fs);
    log('Shader compiled & linked successfully');
    startTime = performance.now();
    // start render loop
    if(animationRequest) cancelAnimationFrame(animationRequest);
    function render(){
      resizeCanvasToDisplaySize(glcanvas);
      gl.viewport(0,0,glcanvas.width,glcanvas.height);
      gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(prog);
      // set uniforms if present
      const timeLoc = gl.getUniformLocation(prog, 'uTime');
      const resLoc = gl.getUniformLocation(prog, 'uResolution');
      const samplerLoc = gl.getUniformLocation(prog, 'uSampler');
      const t = (performance.now() - startTime) / 1000;
      if(timeLoc) gl.uniform1f(timeLoc, t);
      if(resLoc) gl.uniform2f(resLoc, glcanvas.width / devicePixelRatio, glcanvas.height / devicePixelRatio);
      if(samplerLoc){
        // create a simple 1x1 white texture if none provided
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([255,255,255,255]));
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.uniform1i(samplerLoc, 0);
      }

      // full-screen triangle (two triangles)
      const vertices = new Float32Array([-1,-1,1,-1,-1,1,1,1]);
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STREAM_DRAW);
      const posLoc = gl.getAttribLocation(prog, 'aPos');
      if(posLoc >= 0){
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
      }
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.deleteBuffer(vbo);

      animationRequest = requestAnimationFrame(render);
    }
    render();
  }catch(e){
    log('Compile/Link failed: ' + e.message, 'err');
    setStatus('Compile Error');
  }
}

/* ========== Buttons behavior ========== */
document.getElementById('fixBtn').addEventListener('click', ()=>{
  const src = codeEl.innerText;
  setStatus('Running fixer');
  try{
    const fixed = godlikeFix(src);
    // replace editor content with fixed (preserve caret at end)
    codeEl.innerText = fixed;
    updateLineNumbers();
    placeCaretAtEnd(codeEl);
    downloadBtn.style.display = 'inline-block';
    downloadBtn.onclick = downloadFixed;
    setStatus('Fixed ✓');
    animateConfetti(); // celebration
  }catch(e){
    log('Fixer crashed: ' + e.message, 'err');
    setStatus('Fixer Error');
  }
});

document.getElementById('previewBtn').addEventListener('click', ()=>{
  const src = codeEl.innerText;
  setStatus('Compiling preview...');
  try{
    compileAndRun(src);
    setStatus('Preview running');
  }catch(e){
    log('Preview error: ' + e.message, 'err');
    setStatus('Preview Error');
  }
});

document.getElementById('randomBtn').addEventListener('click', ()=>{
  // inject a colorful example with many animations (nice demo)
  const sample = `// Demo: colorful cosine animation
precision mediump float;
uniform float uTime;
uniform vec2 uResolution;
void main(){
  vec2 uv = (gl_FragCoord.xy - 0.5*uResolution.xy)/uResolution.y;
  float d = length(uv);
  vec3 col = vec3(0.5 + 0.5*cos(uTime + uv.xyx*6.0 + vec3(0,2,4)));
  col *= 1.0/(1.0 + d*3.0);
  gl_FragColor = vec4(col,1.0);
}`;
  codeEl.innerText = sample;
  updateLineNumbers();
  log('Injected example shader');
});

function downloadFixed(){
  const txt = codeEl.innerText;
  const blob = new Blob([txt], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = currentFilename.endsWith('.frag')||currentFilename.endsWith('.glsl') ? ('fixed-' + currentFilename) : ('fixed_shader.frag');
  a.click();
  URL.revokeObjectURL(url);
  log('Downloaded fixed shader');
}

/* ========== Log copy / clear ========== */
document.getElementById('copyLog').addEventListener('click', ()=>{
  navigator.clipboard.writeText(logEl.textContent).then(()=>log('Log copied to clipboard'));
});
document.getElementById('clearLog').addEventListener('click', ()=>{
  logEl.textContent = '';
});

/* ========== Confetti animation (canvas) ========= */
confettiCanvas.width = innerWidth;
confettiCanvas.height = innerHeight;
const cctx = confettiCanvas.getContext('2d');
let confettiParticles = [];
function spawnConfetti(){
  const count = 40;
  for(let i=0;i<count;i++){
    confettiParticles.push({
      x: Math.random()*confettiCanvas.width,
      y: -20 - Math.random()*200,
      vx: (Math.random()-0.5)*4,
      vy: 1 + Math.random()*3,
      size: 6 + Math.random()*10,
      rot: Math.random()*360,
      spin: (Math.random()-0.5)*10,
      color: ['#ff6b6b','#6ef0a2','#6b3dff','#4ee0ff','#ffd88e'][Math.floor(Math.random()*5)],
      life: 120 + Math.random()*160
    });
  }
}
function animateConfetti(){
  spawnConfetti();
  let t0 = performance.now();
  function step(){
    cctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
    for(let i=confettiParticles.length-1;i>=0;i--){
      const p = confettiParticles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.04; p.rot += p.spin; p.life--;
      cctx.save();
      cctx.translate(p.x, p.y);
      cctx.rotate(p.rot * Math.PI/180);
      cctx.fillStyle = p.color;
      cctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
      cctx.restore();
      if(p.y > confettiCanvas.height + 50 || p.life <= 0) confettiParticles.splice(i,1);
    }
    if(confettiParticles.length>0) requestAnimationFrame(step);
    else cctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
  }
  requestAnimationFrame(step);
}

/* handle resizing */
window.addEventListener('resize', ()=> {
  confettiCanvas.width = innerWidth;
  confettiCanvas.height = innerHeight;
  resizeCanvasToDisplaySize(glcanvas);
});

/* small accessibility: keyboard shortcuts */
window.addEventListener('keydown',(e)=>{
  if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='s'){
    e.preventDefault();
    downloadFixed();
  }
});

/* final small polish logs */
log('GODLIKE Shader Fixer ready — paste shader and hit AUTO-FIX.');
setStatus('Ready');
</script>
</body>
</html>
