<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GODLIKE Shader Fixer — Online-ready Comments + Fix-with-Logs</title>
<meta name="color-scheme" content="dark">
<style>
:root{
  --bg1:#050717; --bg2:#07132a;
  --accent1:#4ee0ff; --accent2:#b36bff;
  --muted:#9fb9ff66; --glass:rgba(255,255,255,0.04);
  --ui-scale:1;
  --max-width:1200px;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;padding:0;background:linear-gradient(135deg,var(--bg1),var(--bg2));font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,monospace;color:#eaf6ff;overflow:auto}
body{display:flex;align-items:flex-start;justify-content:center;padding:28px 12px}

/* background blobs */
.bgwrap{position:fixed;inset:0;z-index:0;pointer-events:none;overflow:hidden}
.blob{position:absolute;border-radius:50%;filter:blur(72px);opacity:.55;will-change:transform;mix-blend-mode:screen}
.blob.a{width:760px;height:760px;left:-14%;top:2%;background:linear-gradient(45deg,#6b3dff,#00f0ff);animation:floaty 30s linear infinite}
.blob.b{width:520px;height:520px;right:-8%;bottom:-6%;background:linear-gradient(45deg,#ff66b3,#6b3dff);animation:floaty 36s linear infinite;opacity:.36}
@keyframes floaty{0%{transform:translateY(0) rotate(0)}50%{transform:translateY(-60px) rotate(180deg)}100%{transform:translateY(0) rotate(360deg)}}

/* layout */
.app{position:relative;z-index:2;width:100%;max-width:var(--max-width);transition:transform .25s}
.panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:14px;border-radius:14px;box-shadow:0 30px 90px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.04);backdrop-filter: blur(6px)}
.header{display:flex;gap:12px;align-items:center;margin-bottom:12px}
.logo{width:64px;height:64px;border-radius:12px;background:linear-gradient(135deg,var(--accent2),var(--accent1));display:flex;align-items:center;justify-content:center;box-shadow:0 10px 30px rgba(0,0,0,0.35)}
.h1{margin:0;font-size:20px;color:var(--accent1);letter-spacing:.6px}
.lead{margin:0;color:var(--muted);font-size:13px}

/* controls */
.controls{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0;align-items:center}
.btn{border:0;padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:800;letter-spacing:.6px;background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#041826;box-shadow:0 8px 30px rgba(179,107,255,0.12);transition:transform .12s,box-shadow .12s}
.btn:active{transform:translateY(1px)}
.btn.ghost{background:transparent;color:#cfe9ff;border:1px solid rgba(255,255,255,0.04);box-shadow:none}
.fileWrap{position:relative;display:inline-block}
input[type=file]{position:absolute;inset:0;opacity:0;cursor:pointer}

/* main grid */
.grid{display:grid;grid-template-columns:1fr 520px;gap:14px;align-items:start}
@media (max-width:1180px){ .grid{grid-template-columns:1fr} }

/* editor */
.editorBox{min-height:420px;border-radius:12px;overflow:hidden;position:relative}
.ln{position:absolute;left:0;top:0;bottom:0;width:54px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0));color:#9fb9ff66;padding:10px;box-sizing:border-box;font-size:12px;line-height:18px;user-select:none}
.codeArea{margin-left:54px;height:100%;width:100%;box-sizing:border-box;background:#061029;color:#dff3ff;font-family:ui-monospace,monospace;font-size:13px;padding:10px;outline:none;resize:none;overflow:auto;line-height:18px;white-space:pre;caret-color:var(--accent1)}
.codeArea[contenteditable]{-webkit-user-select:text}

/* preview */
.previewCard{padding:10px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));min-height:300px;position:relative;overflow:hidden}
#glcanvas{border-radius:8px;background:#000;display:block;max-width:100%;touch-action:none}

/* right column extras */
.rightCol .panel{margin-bottom:12px}
.log{height:160px;overflow:auto;background:rgba(0,0,0,0.25);padding:10px;border-radius:8px;font-size:12px;color:#cfe9ff;white-space:pre-wrap}
.small{font-size:12px}
.progressWrap{height:8px;background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden}
.progress{height:100%;width:0%;background:linear-gradient(90deg,var(--accent1),var(--accent2));transition:width .4s cubic-bezier(.2,.9,.2,1);box-shadow:0 6px 20px rgba(78,224,255,0.08)}

/* fix-with-logs area */
.fixLogs{display:flex;flex-direction:column;gap:8px}
.fixLogs textarea{width:100%;min-height:80px;padding:10px;border-radius:8px;background:#041227;color:#eaf6ff;border:1px solid rgba(255,255,255,0.04);resize:vertical;font-family:ui-monospace,monospace}

/* comment system */
.comments{display:flex;flex-direction:column;gap:8px}
.commentForm{display:flex;gap:8px;align-items:flex-start}
.commentForm input,.commentForm textarea{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#041227;color:#eaf6ff}
.commentList{max-height:260px;overflow:auto;padding:8px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
.comment{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:8px}

/* modal for connecting Firebase (hidden by default) */
.adminNote{font-size:12px;color:var(--muted);margin-top:6px}

/* confetti */
.confetti{position:fixed;z-index:9999;pointer-events:none}

/* footer */
.footerNote{color:var(--muted);font-size:12px;margin-top:8px}
</style>
</head>
<body>
<div class="bgwrap" aria-hidden="true"><div class="blob a"></div><div class="blob b"></div></div>

<div class="app">
  <div class="panel header" style="align-items:center;">
    <div class="logo" aria-hidden>
      <svg width="36" height="36" viewBox="0 0 24 24" fill="none"><path d="M2 12l3-3 4 4 8-8 5 5" stroke="#041826" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
    </div>
    <div style="flex:1">
      <div class="h1">GODLIKE Shader Fixer</div>
      <div class="lead">Upload .frag/.hx, auto-fix, preview (interactive), fix-with-logs, online-ready comments (Firebase placeholders).</div>
    </div>
    <div style="width:200px;text-align:right">
      <div class="small" id="statusLabel">Status: Ready</div>
    </div>
  </div>

  <div class="grid" style="margin-top:12px">
    <!-- LEFT: editor & fix w/ logs -->
    <div>
      <div class="panel editorBox" style="padding:12px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div><span class="small">Shader Editor</span> <span class="small" id="langBadge">GLSL / Haxe</span></div>
          <div style="display:flex;gap:8px;align-items:center">
            <div class="small">Lines: <span id="lineCount">0</span></div>
            <div style="width:10px"></div>
            <div class="small">Chars: <span id="charCount">0</span></div>
          </div>
        </div>

        <div style="position:relative">
          <div class="ln" id="lineNumbers"></div>
          <div id="code" class="codeArea" contenteditable="true" spellcheck="false" aria-label="Shader code editor"></div>
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
        <div class="fileWrap">
          <button class="btn">Upload Shader</button>
          <input id="fileIn" type="file" accept=".frag,.hx,.glsl,.txt">
        </div>
        <button id="fixBtn" class="btn">AUTO-FIX</button>
        <button id="applyLogFixBtn" class="btn ghost">Fix it with Logs</button>
        <button id="downloadBtn" class="btn" style="display:none">Download Fixed</button>
        <div style="flex:1"></div>
        <button id="injectBtn" class="btn ghost">Inject Example</button>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px">
        <div style="flex:1">
          <div class="progressWrap"><div class="progress" id="progress"></div></div>
        </div>
        <div style="width:220px;text-align:right"><span id="miniNote" class="small">No actions yet</span></div>
      </div>

      <div style="margin-top:12px" class="fixLogs panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Logs</strong> <span class="small" style="color:var(--muted)"> (compiler / fixer output)</span></div>
          <div style="display:flex;gap:8px">
            <button id="copyLogsForFix" class="btn ghost" style="padding:6px 10px">Copy logs</button>
            <button id="pasteLogsToFix" class="btn" style="padding:6px 10px">Paste logs → Fix</button>
          </div>
        </div>
        <div id="mainLog" class="log" style="margin-top:8px"></div>

        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <div style="flex:1">
            <textarea id="logsInput" placeholder="Paste compiler/link logs here (or press 'Paste logs → Fix')"></textarea>
          </div>
          <div style="width:140px;display:flex;flex-direction:column;gap:8px">
            <button id="applyLogsBtn" class="btn">Apply fixes</button>
            <button id="clearLogsInput" class="btn ghost">Clear</button>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: preview, error log, comments -->
    <div class="rightCol">
      <div class="panel previewCard">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div><strong>Interactive Preview</strong> <span class="small" style="color:var(--muted)"> — drag = rotate, pinch/scroll = zoom, click = color offset</span></div>
          <div style="display:flex;gap:8px">
            <button id="runPreview" class="btn ghost" style="padding:8px 10px">Compile & Run</button>
            <button id="stopPreview" class="btn ghost" style="padding:8px 10px">Stop</button>
          </div>
        </div>
        <div style="display:flex;align-items:center;justify-content:center;height:360px;">
          <canvas id="glcanvas" width="640" height="360"></canvas>
        </div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div><strong>Compile & Fix Log</strong></div>
          <div style="display:flex;gap:8px">
            <button id="copyLog" class="btn ghost" style="padding:6px 10px">Copy</button>
            <button id="clearMainLog" class="btn ghost" style="padding:6px 10px">Clear</button>
          </div>
        </div>
        <div id="compileLog" class="log"></div>
      </div>

      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div><strong>Comments (Online-ready)</strong> <span class="small" style="color:var(--muted)"> — nickname + live</span></div>
          <div><button id="connectDemo" class="btn ghost" style="padding:6px 10px">Enable Demo Mode</button></div>
        </div>

        <div class="commentForm" style="margin-bottom:8px">
          <input id="nick" placeholder="nickname (required)" style="flex:0 0 140px">
          <input id="email" placeholder="email (optional)" style="flex:1">
        </div>
        <div class="commentForm" style="margin-bottom:8px">
          <textarea id="commentText" placeholder="Write a comment or paste logs to share..." style="flex:1;height:68px"></textarea>
        </div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-bottom:8px">
          <button id="postComment" class="btn">Post Comment</button>
          <button id="clearComment" class="btn ghost">Clear</button>
        </div>

        <div class="commentList panel" id="commentList" style="max-height:220px;overflow:auto"></div>

        <div class="adminNote" id="firebaseNote">
          This comment area is online-ready. To connect: paste your Firebase config below in the JS section (FIREBASE_CONFIG) and enable authentication rules or anonymous writes. Demo mode uses local-only mock.
        </div>
      </div>
    </div>
  </div>

  <div class="panel footerNote" style="margin-top:12px">
    <strong>Notes for deploy</strong> — This is a single-file app. To enable the live comment system, add your Firebase v9 config to the FIREBASE_CONFIG constant in the script. The placeholder code uses Firestore; you can replace with Realtime DB if desired.
  </div>
</div>

<canvas id="confettiCanvas" class="confetti"></canvas>

<script>
/* =========================
   CONFIG: Add your Firebase config here to enable online comments.
   Example:
   const FIREBASE_CONFIG = {
     apiKey: "XXX",
     authDomain: "yourproject.firebaseapp.com",
     projectId: "yourproject",
     storageBucket: "yourproject.appspot.com",
     messagingSenderId: "123456",
     appId: "1:123:web:abc",
   };
   If left null, the comment system will run in local-demo mode (no external network).
*/
const FIREBASE_CONFIG = null; // <-- paste your Firebase config object here to enable real online comments

/* =========================
   Globals & UI refs
   ========================= */
const fileIn = document.getElementById('fileIn');
const codeEl = document.getElementById('code');
const lineNumbers = document.getElementById('lineNumbers');
const lineCount = document.getElementById('lineCount');
const charCount = document.getElementById('charCount');
const mainLog = document.getElementById('mainLog');
const compileLog = document.getElementById('compileLog');
const progress = document.getElementById('progress');
const statusLabel = document.getElementById('statusLabel');

const fixBtn = document.getElementById('fixBtn');
const applyLogsBtn = document.getElementById('applyLogsBtn');
const applyLogFixBtn = document.getElementById('applyLogFixBtn');
const logsInput = document.getElementById('logsInput');
const copyLogsForFix = document.getElementById('copyLogsForFix');
const pasteLogsToFix = document.getElementById('pasteLogsToFix');
const copyLogBtn = document.getElementById('copyLog');
const clearMainLogBtn = document.getElementById('clearMainLog');
const downloadBtn = document.getElementById('downloadBtn');
const injectBtn = document.getElementById('injectBtn');

const runPreview = document.getElementById('runPreview');
const stopPreview = document.getElementById('stopPreview');

const glcanvas = document.getElementById('glcanvas');
const confettiCanvas = document.getElementById('confettiCanvas');

const nickInput = document.getElementById('nick');
const emailInput = document.getElementById('email');
const commentText = document.getElementById('commentText');
const postComment = document.getElementById('postComment');
const clearComment = document.getElementById('clearComment');
const commentList = document.getElementById('commentList');
const connectDemo = document.getElementById('connectDemo');

let currentFilename = '';
let fixedShaderText = '';
let compileErrors = '';
let demoCommentsMode = true; // fallback to local if no firebase config
let commentsLocal = []; // local cache for demo mode

/* =========================
   Helpers: logger, progress, lines
   ========================= */
function logMain(msg, level='ok'){
  const t = new Date().toLocaleTimeString();
  mainLog.textContent = `${t} [${level.toUpperCase()}] ${msg}\n` + mainLog.textContent;
}
function logCompile(msg, level='ok'){
  const t = new Date().toLocaleTimeString();
  compileLog.textContent = `${t} [${level.toUpperCase()}] ${msg}\n` + compileLog.textContent;
  compileErrors = compileLog.textContent;
}
function setProgress(p){ progress.style.width = p + '%'; }
function setStatus(s){ statusLabel.textContent = 'Status: ' + s; }
function updateLineNumbers(){
  const text = codeEl.innerText.replace(/\t/g,'    ');
  const lines = text.split('\n');
  let html = '';
  for(let i=1;i<=lines.length;i++) html += i + '\n';
  lineNumbers.textContent = html;
  lineCount.textContent = lines.length;
  charCount.textContent = text.length;
}

/* minimal syntax highlight without breaking caret too much */
function applyMinimalHighlight(){
  const txt = codeEl.innerText;
  let html = txt
    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/(\/\/.*?$)/gm, '<span style="color:#8f99a6;font-style:italic">$1</span>')
    .replace(/(\b\d+(\.\d+)?\b)/g, '<span style="color:#a5ffc9">$1</span>')
    .replace(/\b(void|float|vec2|vec3|vec4|uniform|precision|if|else|for|while|return|main|varying|attribute|in|out|sampler2D|gl_FragColor)\b/g, '<span style="color:#7ec7ff">$1</span>')
    .replace(/(\b[a-zA-Z_]\w*(?=\())/g, '<span style="color:#ffd88e">$1</span>');
  codeEl.innerHTML = html;
  placeCaretAtEnd(codeEl);
}
function placeCaretAtEnd(el){
  el.focus();
  if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
    const range = document.createRange();
    range.selectNodeContents(el);
    range.collapse(false);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }
}

/* seed editor with example */
codeEl.innerText = `// Example interactive shader
precision mediump float;
uniform float uTime;
uniform vec2 uResolution;
uniform float uRotate;
uniform float uZoom;
uniform float uColorOffset;
void main(){
  vec2 uv = (gl_FragCoord.xy / uResolution.xy) - 0.5;
  float cr = cos(uRotate), sr = sin(uRotate);
  mat2 R = mat2(cr, -sr, sr, cr);
  uv = R * uv * uZoom;
  float r = length(uv);
  vec3 col = 0.5 + 0.5*cos(uTime + uv.xyx*6.0 + vec3(0,2+uColorOffset,4));
  col *= smoothstep(1.2, 0.0, r);
  gl_FragColor = vec4(col,1.0);
}`;
updateLineNumbers();

/* =========================
   File upload
   ========================= */
document.querySelector('.fileWrap input[type=file]').addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  currentFilename = f.name;
  const text = await f.text();
  codeEl.innerText = text;
  updateLineNumbers();
  logMain('Loaded file: ' + f.name);
  setProgress(6);
});

/* =========================
   Fixer Engine (smart heuristics)
   - this is the heart of "auto-fix" and "fix with logs"
   ========================= */
function smartFixShader(code){
  setStatus('Auto-fixing');
  setProgress(5);
  logMain('Starting smart fix pass');
  let out = code.replace(/\r\n/g,'\n').replace(/\r/g,'\n');

  // 1) Ensure precision
  if(!/precision\s+(lowp|mediump|highp)\s+float\s*;/.test(out)){
    out = 'precision mediump float;\n' + out;
    logMain('Inserted precision mediump float;');
  }
  setProgress(18);

  // 2) Add common Psych uniforms if missing
  const uniforms = [
    {rx:/\buniform\s+float\s+uTime\b, decl:'uniform float uTime;'},
    {rx:/\buniform\s+vec2\s+uResolution\b, decl:'uniform vec2 uResolution;'},
    {rx:/\buniform\s+sampler2D\s+uSampler\b, decl:'uniform sampler2D uSampler;'},
    {rx:/\buniform\s+float\s+uRotate\b, decl:'uniform float uRotate;'},
    {rx:/\buniform\s+float\s+uZoom\b, decl:'uniform float uZoom;'},
    {rx:/\buniform\s+float\s+uColorOffset\b, decl:'uniform float uColorOffset;'}
  ];
  let added=0;
  uniforms.forEach(u=>{
    if(!u.rx.test(out)){ out = u.decl + '\n' + out; added++; }
  });
  if(added) logMain(`Added ${added} common uniform(s)`);
  setProgress(30);

  // 3) Replace deprecated texture2D with texture
  if(/texture2D\(/.test(out)){
    out = out.replace(/texture2D\(/g,'texture(');
    logMain('Replaced texture2D() -> texture()');
  }
  setProgress(42);

  // 4) Smart semicolon insertion (only where safe)
  out = out.split('\n').map(ln=>{
    const t = ln.trim();
    if(!t) return ln;
    if(t.startsWith('//')||t.startsWith('/*')||t.startsWith('*')||t.startsWith('#')) return ln;
    if(/\)\s*{/.test(t) || /\{$/.test(t) || /\}$/.test(t)) return ln;
    if(/[;,\)\{\}]$/.test(t)) return ln;
    if(/^(uniform|attribute|varying|in|out|const)\b/.test(t) && !t.endsWith(';')) return ln + ';';
    if(/=/.test(t) && !/==/.test(t) && !t.endsWith(';')) return ln + ';';
    return ln;
  }).join('\n');
  logMain('Smart semicolons pass');
  setProgress(56);

  // 5) Guard divisions by zero (simple heuristic)
  out = out.replace(/\/\s*\(?([a-zA-Z_]\w*(?:\.[xyzw]{1,4})?)(\)?)/g, (m,g1,g2)=>{
    if(/^\d/.test(g1)) return '/' + g1 + g2;
    return '/ max(' + g1 + ', 0.000001)' + g2;
  });
  logMain('Inserted division guards where identified');
  setProgress(68);

  // 6) Close unbalanced braces/parentheses
  const opens = (out.match(/\{/g)||[]).length;
  const closes = (out.match(/\}/g)||[]).length;
  if(opens > closes){ out += '\n' + '}'.repeat(opens - closes); logMain(`Auto-closed ${opens-closes} missing brace(s)`); }
  const opar = (out.match(/\(/g)||[]).length;
  const cpar = (out.match(/\)/g)||[]).length;
  if(opar > cpar){ out += ')'.repeat(opar - cpar); logMain(`Auto-closed ${opar-cpar} missing parenthesis`); }
  setProgress(78);

  // 7) Replace literal 'undefined' or common placeholders
  out = out.replace(/\bundefined\b/g,'0.0');
  out = out.replace(/\bNULL\b/g,'0.0');
  logMain('Replaced undefined/NULL placeholders');

  // 8) Fix obvious type mismatches: vecX = float -> vecX(vec)
  out = out.replace(/\b(vec[234])\s+([a-zA-Z_]\w*)\s*=\s*([0-9]+(?:\.[0-9]+)?)\s*;/g, '$1 $2 = $1($3);');
  setProgress(88);

  // 9) Ensure a main() exists
  if(!/\bvoid\s+main\s*\(/.test(out)){
    out += '\nvoid main(){ gl_FragColor = vec4(0.0,0.0,0.0,1.0); }';
    logMain('Appended safe main() because none found');
  }

  setProgress(100);
  setTimeout(()=>setProgress(0),700);
  logMain('Smart fix pass complete');
  fixedShaderText = out;
  return out;
}

/* =========================
   Fix with Logs: parse log & fix
   - parse common shader compiler errors and apply fixes heuristically
   ========================= */
function parseErrorsAndFix(code, logsText){
  setStatus('Fixing (logs)');
  setProgress(6);
  logMain('Parsing logs to derive fixes...');

  // Basic parsing: gather error lines (common formats)
  const lines = logsText.split('\n').map(l=>l.trim()).filter(Boolean);
  const errorLines = lines.filter(l => /error|ERROR|Error|failed|unknown/i.test(l));
  if(errorLines.length === 0){
    // fallback: include the full logs (user might have pasted raw messages)
    errorLines.push(...lines);
  }

  let patched = code;

  // heuristics map
  errorLines.forEach(el => {
    // Missing semicolon (very common)
    if(/';'|missing ';'|expected ';'/.test(el) || /syntax error.*expected ';'/.test(el)){
      // attempt to add semicolons to suspicious lines
      patched = patched.split('\n').map(ln=>{
        const t = ln.trim();
        if(!t) return ln;
        if(t.startsWith('//')||t.startsWith('#')||t.endsWith(';')||t.endsWith('{')||t.endsWith('}')) return ln;
        if(/[;,\)\{\}]$/.test(t)) return ln;
        if(/=/.test(t) && !/==/.test(t)) return ln + ';';
        return ln;
      }).join('\n');
      logMain('Applied missing semicolon heuristic from logs');
    }

    // undeclared identifier
    let m = el.match(/'(.*?)' : undeclared identifier/);
    if(m && m[1]){
      const id = m[1];
      // guess it's a float or vec2... default to float
      patched = `uniform float ${id};\n` + patched;
      logMain(`Declared missing identifier ${id} as uniform float (heuristic)`);
    }

    // 'assigning integer to vec' or type mismatch
    if(/cannot convert|assign.*to.*vec/i.test(el)){
      // try wrapping numeric literals in vec3(...) if appropriate (simple heuristic)
      patched = patched.replace(/=\s*([0-9]+(?:\.[0-9]+)?)\s*;/g, '= vec3($1);');
      logMain('Applied simple numeric->vec3 wrapping from logs');
    }

    // 'texture2D' warnings
    if(/texture2D\(/.test(el) || /texture\(/.test(el) && patched.includes('texture2D(')){
      patched = patched.replace(/texture2D\(/g,'texture(');
      logMain('Converted texture2D->texture based on logs');
    }

    // 'cannot implicitly convert' errors for int/float
    if(/implicitly convert/i.test(el)){
      patched = patched.replace(/\b([0-9]+)\b/g, '$1.0');
      logMain('Converted integer literals to float literals where ambiguous');
    }

    // linker errors like "undefined reference to 'main'"
    if(/undefined reference to .*main|no main function/.test(el.toLowerCase())){
      if(!/\bvoid\s+main\s*\(/.test(patched)){
        patched += '\nvoid main(){ gl_FragColor = vec4(0.0,0.0,0.0,1.0); }';
        logMain('Added fallback main() due to linker errors in logs');
      }
    }

    // mismatched braces/parens: if logs mention line numbers, best-effort close
    if(/unmatched|missing.*brace|missing.*parenth/i.test(el)){
      const opens = (patched.match(/\{/g)||[]).length;
      const closes = (patched.match(/\}/g)||[]).length;
      if(opens>closes){ patched += '\n' + '}'.repeat(opens-closes); logMain('Auto-closed braces after reading logs'); }
      const opar = (patched.match(/\(/g)||[]).length;
      const cpar = (patched.match(/\)/g)||[]).length;
      if(opar>cpar){ patched += ')'.repeat(opar-cpar); logMain('Auto-closed parentheses after reading logs'); }
    }
  });

  // Final generic passes
  patched = smartFixShader(patched); // run the general fixer to ensure consistency
  setStatus('Fix-with-logs complete');
  setProgress(0);
  return patched;
}

/* =========================
   Buttons for Fix / Fix-with-Logs
   ========================= */
fixBtn.addEventListener('click', ()=>{
  try{
    const src = codeEl.innerText;
    const fixed = smartFixShader(src);
    codeEl.innerText = fixed;
    updateLineNumbers();
    downloadBtn.style.display = 'inline-block';
    fixedShaderText = fixed;
    logCompile('Auto-fix applied successfully');
    animateConfetti();
  }catch(e){
    logCompile('Auto-fix crashed: ' + e.message,'err');
  }
});

copyLogsForFix.addEventListener('click', ()=>{
  navigator.clipboard.writeText(compileLog.textContent).then(()=>logMain('Compile log copied to clipboard'));
});

pasteLogsToFix.addEventListener('click', async ()=>{
  const txt = await navigator.clipboard.readText().catch(()=>null);
  if(!txt) return alert('Clipboard empty or permission denied.');
  logsInput.value = txt;
  logMain('Pasted clipboard into Logs input');
});

applyLogsBtn.addEventListener('click', ()=>{
  const logsText = logsInput.value.trim();
  if(!logsText) return alert('Paste logs into the input first.');
  const src = codeEl.innerText;
  try{
    const patched = parseErrorsAndFix(src, logsText);
    codeEl.innerText = patched;
    updateLineNumbers();
    downloadBtn.style.display = 'inline-block';
    logCompile('Applied fixes derived from logs.');
    animateConfetti();
  }catch(e){
    logCompile('Fix-with-logs failed: ' + e.message,'err');
  }
});

/* quick "applyLogFixBtn" => copies main compile log into logs input then runs */
applyLogFixBtn.addEventListener('click', ()=>{
  logsInput.value = compileLog.textContent;
  applyLogsBtn.click();
});

/* clear logs / copy compile log */
copyLogBtn.addEventListener('click', ()=>{ navigator.clipboard.writeText(compileLog.textContent).then(()=>logMain('Compile log copied')); });
clearMainLogBtn.addEventListener('click', ()=>{ compileLog.textContent=''; logMain('Compile log cleared'); });

/* inject example + download */
injectBtn.addEventListener('click', ()=>{
  const sample = `// Demo: interactive shader
precision mediump float;
uniform float uTime;
uniform vec2 uResolution;
uniform float uRotate;
uniform float uZoom;
uniform float uColorOffset;
void main(){
  vec2 uv = (gl_FragCoord.xy / uResolution.xy) - 0.5;
  float cr = cos(uRotate), sr = sin(uRotate);
  mat2 R = mat2(cr, -sr, sr, cr);
  uv = R * uv * uZoom;
  float r = length(uv);
  vec3 col = 0.5 + 0.5*cos(uTime + uv.xyx*6.0 + vec3(0,2+uColorOffset,4));
  col *= smoothstep(1.2, 0.0, r);
  gl_FragColor = vec4(col,1.0);
}`;
  codeEl.innerText = sample;
  updateLineNumbers();
  logMain('Injected example shader');
});

downloadBtn.addEventListener('click', ()=>{
  const txt = codeEl.innerText;
  const blob = new Blob([txt], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = currentFilename ? ('fixed-' + currentFilename) : 'fixed_shader.frag';
  a.click();
  URL.revokeObjectURL(url);
  logMain('Downloaded fixed shader');
});

/* =========================
   WebGL preview (interactive uniforms)
   ========================= */
const gl = glcanvas.getContext('webgl') || glcanvas.getContext('experimental-webgl');
if(!gl){
  logCompile('WebGL not supported in this browser — preview disabled', 'err');
  runPreview.disabled = true;
}

let program = null;
let animReq = null;
let startTime = performance.now();
let interaction = { rotation:0, zoom:1, colorOffset:0, dragging:false, lastX:0, lastY:0, pinchDist:0 };

function resizeCanvasToFit(){
  // fit container width while maintaining current canvas aspect ratio
  const parent = glcanvas.parentElement;
  const maxW = Math.min(parent.clientWidth, 720);
  const aspect = glcanvas.width / (glcanvas.height || 360);
  // Keep physical pixel sizes reasonable
  const cssW = Math.floor(Math.min(maxW, window.innerWidth * 0.9));
  const cssH = Math.floor(cssW / (glcanvas.width / glcanvas.height));
  glcanvas.style.width = cssW + 'px';
  glcanvas.style.height = cssH + 'px';
  glcanvas.width = Math.floor(cssW * devicePixelRatio);
  glcanvas.height = Math.floor(cssH * devicePixelRatio);
}

function compileAndRun(fragmentSource){
  if(!gl) return;
  resizeCanvasToFit();
  const vsSource = `attribute vec2 aPos; void main(){ gl_Position = vec4(aPos,0.0,1.0); }`;
  function createShader(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      const info = gl.getShaderInfoLog(s);
      gl.deleteShader(s);
      throw new Error(info);
    }
    return s;
  }

  try{
    const vs = createShader(gl.VERTEX_SHADER, vsSource);
    const fs = createShader(gl.FRAGMENT_SHADER, fragmentSource);
    if(program){ gl.deleteProgram(program); program = null; }
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
      const info = gl.getProgramInfoLog(p);
      gl.deleteProgram(p);
      throw new Error('Link error: ' + info);
    }
    program = p;
    startTime = performance.now();

    if(animReq) cancelAnimationFrame(animReq);
    function render(){
      resizeCanvasToFit();
      gl.viewport(0,0,glcanvas.width,glcanvas.height);
      gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(program);

      // uniforms
      const tloc = gl.getUniformLocation(program, 'uTime');
      const rloc = gl.getUniformLocation(program, 'uResolution');
      const rotloc = gl.getUniformLocation(program, 'uRotate');
      const zloc = gl.getUniformLocation(program, 'uZoom');
      const coloff = gl.getUniformLocation(program, 'uColorOffset');
      const samplerLoc = gl.getUniformLocation(program, 'uSampler');

      const t = (performance.now() - startTime) / 1000;
      if(tloc) gl.uniform1f(tloc, t);
      if(rloc) gl.uniform2f(rloc, glcanvas.width / devicePixelRatio, glcanvas.height / devicePixelRatio);
      if(rotloc) gl.uniform1f(rotloc, interaction.rotation);
      if(zloc) gl.uniform1f(zloc, interaction.zoom);
      if(coloff) gl.uniform1f(coloff, interaction.colorOffset);

      if(samplerLoc){
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,new Uint8Array([255,255,255,255]));
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, tex); gl.uniform1i(samplerLoc, 0);
      }

      const verts = new Float32Array([-1,-1,1,-1,-1,1,1,1]);
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STREAM_DRAW);
      const posLoc = gl.getAttribLocation(program, 'aPos');
      if(posLoc >= 0){
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
      }
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.deleteBuffer(vbo);

      animReq = requestAnimationFrame(render);
    }
    render();
    logCompile('Compiled & running preview');
    setStatus('Preview running');
  }catch(e){
    logCompile('Compile/Link failed: ' + e.message, 'err');
    setStatus('Compile Error');
  }
}

runPreview.addEventListener('click', ()=>{
  const src = codeEl.innerText;
  try{ compileAndRun(src); }catch(e){ logCompile('Preview error: ' + e.message,'err'); }
});
stopPreview.addEventListener('click', ()=>{
  if(animReq) cancelAnimationFrame(animReq);
  if(program) { gl.deleteProgram(program); program = null; }
  setStatus('Preview stopped');
});

/* =========================
   Canvas interaction: drag rotate, wheel/pinch zoom, click colorOffset
   ========================= */
glcanvas.addEventListener('pointerdown', (ev)=>{
  glcanvas.setPointerCapture(ev.pointerId);
  interaction.dragging = true;
  interaction.lastX = ev.clientX;
  interaction.lastY = ev.clientY;
});
glcanvas.addEventListener('pointermove', (ev)=>{
  if(!interaction.dragging) return;
  const dx = ev.clientX - interaction.lastX;
  interaction.lastX = ev.clientX;
  interaction.lastY = ev.clientY;
  interaction.rotation += (dx / Math.max(glcanvas.clientWidth, glcanvas.clientHeight)) * Math.PI;
});
glcanvas.addEventListener('pointerup', (ev)=>{
  glcanvas.releasePointerCapture(ev.pointerId);
  interaction.dragging = false;
});
glcanvas.addEventListener('pointercancel', ()=>{ interaction.dragging = false; });

glcanvas.addEventListener('wheel', (ev)=>{
  ev.preventDefault();
  const d = -ev.deltaY * 0.0018;
  interaction.zoom = Math.max(0.2, Math.min(6, interaction.zoom * (1 + d)));
}, {passive:false});

glcanvas.addEventListener('click', ()=>{ interaction.colorOffset += 0.9; });

/* touch pinch handlers */
glcanvas.addEventListener('touchstart', (ev)=>{
  if(ev.touches.length === 2){
    const d = Math.hypot(ev.touches[0].clientX - ev.touches[1].clientX, ev.touches[0].clientY - ev.touches[1].clientY);
    interaction.pinchDist = d;
  } else if(ev.touches.length === 1){
    interaction.dragging = true;
    interaction.lastX = ev.touches[0].clientX;
    interaction.lastY = ev.touches[0].clientY;
  }
}, {passive:true});

glcanvas.addEventListener('touchmove', (ev)=>{
  if(ev.touches.length === 2 && interaction.pinchDist){
    const nd = Math.hypot(ev.touches[0].clientX - ev.touches[1].clientX, ev.touches[0].clientY - ev.touches[1].clientY);
    const scale = nd / interaction.pinchDist;
    interaction.zoom = Math.max(0.2, Math.min(6, interaction.zoom * scale));
    interaction.pinchDist = nd;
  } else if(ev.touches.length === 1 && interaction.dragging){
    const dx = ev.touches[0].clientX - interaction.lastX;
    interaction.lastX = ev.touches[0].clientX;
    interaction.rotation += (dx / Math.max(glcanvas.clientWidth, glcanvas.clientHeight)) * Math.PI;
  }
}, {passive:true});

glcanvas.addEventListener('touchend', (ev)=>{
  interaction.pinchDist = null;
  interaction.dragging = false;
}, {passive:true});

/* double-tap reset */
glcanvas.addEventListener('dblclick', ()=>{
  interaction.rotation = 0; interaction.zoom = 1; interaction.colorOffset = 0;
});

/* =========================
   Confetti (visual reward)
   ========================= */
confettiCanvas.width = innerWidth; confettiCanvas.height = innerHeight;
const cctx = confettiCanvas.getContext('2d'); let confettiParticles = [];
function spawnConfetti(){
  const count = 28;
  for(let i=0;i<count;i++){
    confettiParticles.push({
      x: Math.random()*confettiCanvas.width,
      y: -20 - Math.random()*200,
      vx: (Math.random()-0.5)*6,
      vy: 1 + Math.random()*4,
      size: 6 + Math.random()*12,
      rot: Math.random()*360,
      spin: (Math.random()-0.5)*10,
      color: ['#ff6b6b','#6ef0a2','#6b3dff','#4ee0ff','#ffd88e'][Math.floor(Math.random()*5)],
      life: 120 + Math.random()*180
    });
  }
}
function animateConfetti(){
  spawnConfetti();
  function step(){
    cctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
    for(let i=confettiParticles.length-1;i>=0;i--){
      const p = confettiParticles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.rot += p.spin; p.life--;
      cctx.save();
      cctx.translate(p.x, p.y);
      cctx.rotate(p.rot * Math.PI/180);
      cctx.fillStyle = p.color;
      cctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
      cctx.restore();
      if(p.y > confettiCanvas.height + 50 || p.life <= 0) confettiParticles.splice(i,1);
    }
    if(confettiParticles.length>0) requestAnimationFrame(step);
    else cctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
  }
  requestAnimationFrame(step);
}

/* =========================
   Comments: Online-ready (Firestore) OR demo local
   - uses Firebase v9 modular SDK if FIREBASE_CONFIG provided.
   ========================= */
let firestore = null;
let firebaseApp = null;
let commentsUnsub = null;

async function initCommentsOnline(){
  if(!FIREBASE_CONFIG) return false;
  try{
    // load firebase libraries dynamically
    const { initializeApp } = await import('https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js');
    const { getFirestore, collection, addDoc, doc, onSnapshot, query, orderBy, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js');

    firebaseApp = initializeApp(FIREBASE_CONFIG);
    firestore = getFirestore(firebaseApp);

    // subscribe to comments collection (live)
    const q = query(collection(firestore, 'shader_comments'), orderBy('ts','desc'));
    commentsUnsub = onSnapshot(q, (snap) => {
      commentList.innerHTML = '';
      snap.forEach(docSnap => {
        const d = docSnap.data();
        appendCommentToUI(d.nick || 'anon', d.text || '', d.ts ? new Date(d.ts.toMillis()).toLocaleString() : new Date().toLocaleString());
      });
    });

    demoCommentsMode = false;
    logMain('Connected to Firestore for comments (live).');
    return true;
  }catch(e){
    console.warn('Firebase init failed', e);
    logMain('Failed to init Firebase — falling back to demo local comments.', 'warn');
    demoCommentsMode = true;
    return false;
  }
}

async function postCommentOnline(nick, email, text){
  if(!firestore) return false;
  try{
    const { collection, addDoc, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js');
    await addDoc(collection(firestore, 'shader_comments'), {
      nick, email, text, ts: serverTimestamp()
    });
    return true;
  }catch(e){
    console.warn('postCommentOnline failed', e);
    return false;
  }
}

function appendCommentToUI(nick, text, time){ 
  const c = document.createElement('div');
  c.className = 'comment';
  c.innerHTML = `<div style="display:flex;justify-content:space-between"><strong>${escapeHtml(nick)}</strong><span class="small">${escapeHtml(time)}</span></div><div style="margin-top:6px;white-space:pre-wrap">${escapeHtml(text)}</div>`;
  commentList.prepend(c);
}

function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

/* Demo local comments */
function addLocalComment(nick, email, text){
  const now = new Date();
  commentsLocal.unshift({nick, email, text, ts: now});
  // render
  appendCommentToUI(nick, text, now.toLocaleString());
}

/* connect demo mode if FIREBASE_CONFIG is absent; show instructions */
connectDemo.addEventListener('click', async ()=>{
  if(FIREBASE_CONFIG){
    const ok = await initCommentsOnline();
    if(ok) { alert('Connected to Firestore. Comments are live.'); return; }
  }
  demoCommentsMode = true;
  alert('Demo comments enabled — local only. To enable online live comments paste FIREBASE_CONFIG into the script.');
});

/* post comment button */
postComment.addEventListener('click', async ()=>{
  const nick = (nickInput.value || '').trim() || 'anon';
  const email = (emailInput.value || '').trim();
  const text = (commentText.value || '').trim();
  if(!text) return alert('Write something to post.');
  if(!demoCommentsMode && FIREBASE_CONFIG && firestore){
    const ok = await postCommentOnline(nick, email, text);
    if(ok) { commentText.value=''; logMain('Comment posted (online)'); return; }
    // fallback
    logMain('Failed to post online — storing locally', 'warn');
  }
  addLocalComment(nick, email, text);
  commentText.value='';
  logMain('Comment posted (local demo)');
});

/* clear comment UI */
clearComment.addEventListener('click', ()=>{ nickInput.value=''; emailInput.value=''; commentText.value=''; });

/* init comments mode: attempt to connect if config present; otherwise demo */
(async ()=>{
  if(FIREBASE_CONFIG){
    await initCommentsOnline();
    if(demoCommentsMode){
      // show sample local comments for demo
      addLocalComment('System', '', 'Connected: demo local comments. Paste your Firebase config to enable live comments.');
    }
  } else {
    addLocalComment('System', '', 'Demo mode: comments are local-only. Paste FIREBASE_CONFIG in the script to enable live comments.');
  }
})();

/* =========================
   Utility: apply highlighting and update counters periodically
   ========================= */
setInterval(()=>{ try{ applyMinimalHighlight(); updateLineNumbers(); }catch(e){} }, 1500);

/* expose a simple API in the console for advanced users */
window.GODFIX = {
  smartFixShader,
  parseErrorsAndFix,
  compileAndRun,
  getCompileLog: () => compileLog.textContent,
  getMainLog: () => mainLog.textContent
};

/* final small polish logs */
logMain('GODLIKE Shader Fixer loaded — paste your shader or upload a .frag/.hx file.');
logCompile('Compile log ready.');

</script>
</body>
</html>